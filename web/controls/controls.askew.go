package controls

// Code generated by askew. DO NOT EDIT.

import (
	"syscall/js"

	askew "github.com/flyx/askew/runtime"
)

// DropdownController can be implemented to handle external events
// generated by Dropdown
type DropdownController interface {
	ItemClicked(index int) bool
}

var αDropdownTemplate = js.Global().Get("document").Call("createElement", "template")

func init() {
	αDropdownTemplate.Set("innerHTML", `
  <!--controller-->
	<!--data-->
	<!--handlers-->
  <div class="pure-menu pure-menu-horizontal dropdown-container">
    <ul class="pure-menu-list">
      <li class="pure-menu-item pure-menu-has-children dropdown-selector">
        <a href="#" class="pure-menu-link">
          <span></span>
          <i class="fas fa-caret-down"></i>
        </a>
        <ul class="pure-menu-children">
          <!--embed(items)-->
        </ul>
      </li>
    </ul>
  </div>
`)
}

// Dropdown is a DOM component autogenerated by Askew
type Dropdown struct {
	αcd askew.ComponentData
	// Controller is the adapter for events generated from this component.
	// if nil, events that would be passed to the controller will not be handled.
	Controller  DropdownController
	opened      askew.BoolValue
	Disabled    askew.BoolValue
	link        askew.RawValue
	emphCaption askew.BoolValue
	caption     askew.StringValue
	menuHeight  askew.StringValue
	kind        SelectorKind
	indicator   IndicatorKind
	CurIndex    int
	items       dropdownItemList
}

// FirstNode returns the first DOM node of this component.
// It implements the askew.Component interface.
func (o *Dropdown) FirstNode() js.Value {
	return o.αcd.First()
}

// askewInit initializes the component, discarding all previous information.
// The component is initially a DocumentFragment until it gets inserted into
// the main document. It can be manipulated both before and after insertion.
func (o *Dropdown) askewInit(kind SelectorKind, indicator IndicatorKind) {
	o.αcd.Init(αDropdownTemplate.Get("content").Call("cloneNode", true))
	o.kind = kind
	o.indicator = indicator

	o.opened.BoundValue = askew.NewBoundClasses(&o.αcd, []string{"pure-menu-active"}, 7, 1, 1)
	o.Disabled.BoundValue = askew.NewBoundClasses(&o.αcd, []string{"pure-menu-disabled"}, 7, 1, 1, 1)
	o.link.BoundValue = askew.NewBoundSelf(&o.αcd, 7, 1, 1, 1)
	o.emphCaption.BoundValue = askew.NewBoundClasses(&o.αcd, []string{"emph"}, 7, 1, 1, 1)
	o.caption.BoundValue = askew.NewBoundProperty(&o.αcd, "textContent", 7, 1, 1, 1, 1)
	o.menuHeight.BoundValue = askew.NewBoundStyle(&o.αcd, "height", 7, 1, 1, 3)
	{
		src := o.αcd.Walk(7, 1, 1, 1)
		{
			wrapper := js.FuncOf(func(this js.Value, arguments []js.Value) interface{} {
				o.αcallclick()
				arguments[0].Call("preventDefault")
				return nil
			})
			src.Call("addEventListener", "click", wrapper)
		}
	}
	{
		container := o.αcd.Walk(7, 1, 1, 3)
		o.items.Init(container, 1)
		o.items.DefaultController = o

	}
}

// InsertInto inserts this component into the given object.
// The component will be in inserted state afterwards.
//
// The component will be inserted in front of 'before', or at the end if 'before' is 'js.Undefined()'.
func (o *Dropdown) InsertInto(parent js.Value, before js.Value) {
	o.αcd.DoInsert(parent, before)
	o.items.αmgr.UpdateParent(o.αcd.DocumentFragment(), parent, before)
}

// Extract removes this component from its current parent.
// The component will be in initial state afterwards.
func (o *Dropdown) Extract() {
	o.αcd.DoExtract()
	o.items.αmgr.UpdateParent(o.αcd.First().Get("parentNode"), o.αcd.DocumentFragment(), js.Undefined())
}

// Destroy destroys this element (and all contained components). If it is
// currently inserted anywhere, it gets removed before.
func (o *Dropdown) Destroy() {
	o.items.DestroyAll()
	o.αcd.DoDestroy()
}

func (o *Dropdown) αcallclick() {
	o.click()
}
func (o *Dropdown) αcallItemClicked(index askew.BoundValue) bool {
	if o.Controller == nil {
		return false
	}
	_index := askew.IntValue{BoundValue: index}
	return o.Controller.ItemClicked(_index.Get())
}

// PopupBaseController can be implemented to handle external events
// generated by PopupBase
type PopupBaseController interface {
	Cancel()
	Confirm()
	DoShow()
	NeedsDoShow() bool
}

var αPopupBaseTemplate = js.Global().Get("document").Call("createElement", "template")

func init() {
	αPopupBaseTemplate.Set("innerHTML", `
	<!--controller-->
	<div id="popup-wrapper">
		<form id="popup" class="pure-form">
			<h3></h3>
			<section><!--embed(Content)--></section>
			<button type="button" class="pure-button"></button>
			<button type="submit" class="pure-button pure-button-primary"></button>
		</form>
	</div>
`)
}

// PopupBase is a DOM component autogenerated by Askew
type PopupBase struct {
	αcd askew.ComponentData
	// Controller is the adapter for events generated from this component.
	// if nil, events that would be passed to the controller will not be handled.
	Controller     PopupBaseController
	Display        askew.StringValue
	Visibility     askew.StringValue
	Title          askew.StringValue
	CancelCaption  askew.StringValue
	cancelVisible  askew.StringValue
	ConfirmCaption askew.StringValue
	Content        askew.GenericOptional
}

// NewPopupBase creates a new component and initializes it with the given parameters.
func NewPopupBase() *PopupBase {
	ret := new(PopupBase)
	ret.askewInit()
	return ret
}

// Init initializes the component with the given arguments.
func (o *PopupBase) Init() {
	o.askewInit()
}

// FirstNode returns the first DOM node of this component.
// It implements the askew.Component interface.
func (o *PopupBase) FirstNode() js.Value {
	return o.αcd.First()
}

// askewInit initializes the component, discarding all previous information.
// The component is initially a DocumentFragment until it gets inserted into
// the main document. It can be manipulated both before and after insertion.
func (o *PopupBase) askewInit() {
	o.αcd.Init(αPopupBaseTemplate.Get("content").Call("cloneNode", true))

	o.Display.BoundValue = askew.NewBoundStyle(&o.αcd, "display", 3)
	o.Visibility.BoundValue = askew.NewBoundStyle(&o.αcd, "visibility", 3)
	o.Title.BoundValue = askew.NewBoundProperty(&o.αcd, "textContent", 3, 1, 1)
	o.CancelCaption.BoundValue = askew.NewBoundProperty(&o.αcd, "textContent", 3, 1, 5)
	o.cancelVisible.BoundValue = askew.NewBoundStyle(&o.αcd, "visibility", 3, 1, 5)
	o.ConfirmCaption.BoundValue = askew.NewBoundProperty(&o.αcd, "textContent", 3, 1, 7)
	{
		src := o.αcd.Walk(3, 1)
		{
			wrapper := js.FuncOf(func(this js.Value, arguments []js.Value) interface{} {
				o.αcallConfirm()
				arguments[0].Call("preventDefault")
				return nil
			})
			src.Call("addEventListener", "submit", wrapper)
		}
	}
	{
		src := o.αcd.Walk(3, 1, 5)
		{
			wrapper := js.FuncOf(func(this js.Value, arguments []js.Value) interface{} {
				o.αcallCancel()
				arguments[0].Call("preventDefault")
				return nil
			})
			src.Call("addEventListener", "click", wrapper)
		}
	}
	{
		container := o.αcd.Walk(3, 1, 3)
		o.Content.Init(container, 0)

	}
}

// InsertInto inserts this component into the given object.
// The component will be in inserted state afterwards.
//
// The component will be inserted in front of 'before', or at the end if 'before' is 'js.Undefined()'.
func (o *PopupBase) InsertInto(parent js.Value, before js.Value) {
	o.αcd.DoInsert(parent, before)
	o.Content.DoUpdateParent(o.αcd.DocumentFragment(), parent, before)
}

// Extract removes this component from its current parent.
// The component will be in initial state afterwards.
func (o *PopupBase) Extract() {
	o.αcd.DoExtract()
	o.Content.DoUpdateParent(o.αcd.First().Get("parentNode"), o.αcd.DocumentFragment(), js.Undefined())
}

// Destroy destroys this element (and all contained components). If it is
// currently inserted anywhere, it gets removed before.
func (o *PopupBase) Destroy() {
	o.Content.Set(nil)
	o.αcd.DoDestroy()
}

func (o *PopupBase) αcallCancel() {
	if o.Controller == nil {
		return
	}
	o.Controller.Cancel()
}
func (o *PopupBase) αcallConfirm() {
	if o.Controller == nil {
		return
	}
	o.Controller.Confirm()
}
func (o *PopupBase) αcallDoShow() {
	if o.Controller == nil {
		return
	}
	o.Controller.DoShow()
}
func (o *PopupBase) αcallNeedsDoShow() bool {
	if o.Controller == nil {
		return false
	}
	return o.Controller.NeedsDoShow()
}

// SwitchController can be implemented to handle external events
// generated by Switch
type SwitchController interface {
	Swapped()
}

var αSwitchTemplate = js.Global().Get("document").Call("createElement", "template")

func init() {
	αSwitchTemplate.Set("innerHTML", `
  <!--controller-->
  <label class="switch">
    <input type="checkbox"/>
    <span class="slider"></span>
  </label>
`)
}

// Switch is a DOM component autogenerated by Askew
type Switch struct {
	αcd askew.ComponentData
	// Controller is the adapter for events generated from this component.
	// if nil, events that would be passed to the controller will not be handled.
	Controller SwitchController
	Value      askew.BoolValue
}

// NewSwitch creates a new component and initializes it with the given parameters.
func NewSwitch() *Switch {
	ret := new(Switch)
	ret.askewInit()
	return ret
}

// Init initializes the component with the given arguments.
func (o *Switch) Init() {
	o.askewInit()
}

// FirstNode returns the first DOM node of this component.
// It implements the askew.Component interface.
func (o *Switch) FirstNode() js.Value {
	return o.αcd.First()
}

// askewInit initializes the component, discarding all previous information.
// The component is initially a DocumentFragment until it gets inserted into
// the main document. It can be manipulated both before and after insertion.
func (o *Switch) askewInit() {
	o.αcd.Init(αSwitchTemplate.Get("content").Call("cloneNode", true))

	o.Value.BoundValue = askew.NewBoundProperty(&o.αcd, "checked", 3, 1)
	{
		src := o.αcd.Walk(3, 1)
		{
			wrapper := js.FuncOf(func(this js.Value, arguments []js.Value) interface{} {
				o.αcallSwapped()
				return nil
			})
			src.Call("addEventListener", "change", wrapper)
		}
	}
}

// InsertInto inserts this component into the given object.
// The component will be in inserted state afterwards.
//
// The component will be inserted in front of 'before', or at the end if 'before' is 'js.Undefined()'.
func (o *Switch) InsertInto(parent js.Value, before js.Value) {
	o.αcd.DoInsert(parent, before)
}

// Extract removes this component from its current parent.
// The component will be in initial state afterwards.
func (o *Switch) Extract() {
	o.αcd.DoExtract()
}

// Destroy destroys this element (and all contained components). If it is
// currently inserted anywhere, it gets removed before.
func (o *Switch) Destroy() {
	o.αcd.DoDestroy()
}

func (o *Switch) αcallSwapped() {
	if o.Controller == nil {
		return
	}
	o.Controller.Swapped()
}

// dropdownItemController can be implemented to handle external events
// generated by dropdownItem
type dropdownItemController interface {
	clickItem(index int)
}

var αdropdownItemTemplate = js.Global().Get("document").Call("createElement", "template")

func init() {
	αdropdownItemTemplate.Set("innerHTML", `
  <!--controller-->
  <li class="pure-menu-item">
    <a href="#" class="pure-menu-link">
			<i class="fas fa-check-circle dropdown-visible"></i>
      <i class="fas fa-eye dropdown-visible"></i>
      <i class="fas fa-eye-slash dropdown-invisible"></i>
      <span></span>
    </a>
  </li>
`)
}

// dropdownItem is a DOM component autogenerated by Askew
type dropdownItem struct {
	αcd askew.ComponentData
	// Controller is the adapter for events generated from this component.
	// if nil, events that would be passed to the controller will not be handled.
	Controller dropdownItemController
	Selected   askew.BoolValue
	caption    askew.StringValue
}

// newDropdownItem creates a new component and initializes it with the given parameters.
func newDropdownItem(indicator IndicatorKind, emph bool, itemName string, itemIndex int) *dropdownItem {
	ret := new(dropdownItem)
	ret.askewInit(indicator, emph, itemName, itemIndex)
	return ret
}

// Init initializes the component with the given arguments.
func (o *dropdownItem) Init(indicator IndicatorKind, emph bool, itemName string, itemIndex int) {
	o.askewInit(indicator, emph, itemName, itemIndex)
}

// FirstNode returns the first DOM node of this component.
// It implements the askew.Component interface.
func (o *dropdownItem) FirstNode() js.Value {
	return o.αcd.First()
}

// askewInit initializes the component, discarding all previous information.
// The component is initially a DocumentFragment until it gets inserted into
// the main document. It can be manipulated both before and after insertion.
func (o *dropdownItem) askewInit(indicator IndicatorKind, emph bool, itemName string, itemIndex int) {
	o.αcd.Init(αdropdownItemTemplate.Get("content").Call("cloneNode", true))

	o.Selected.BoundValue = askew.NewBoundClasses(&o.αcd, []string{"pure-menu-selected"}, 3)
	o.caption.BoundValue = askew.NewBoundProperty(&o.αcd, "textContent", 3, 1, 7)
	{
		block := o.αcd.Walk()
		{
			var tmp askew.BoundDataset
			tmp.Init(askew.WalkPath(block, 3, 1), "index")
			askew.Assign(&tmp, itemIndex)
		}
		{
			var tmp askew.BoundClasses
			tmp.Init(askew.WalkPath(block, 3, 1), []string{"emph"})
			askew.Assign(&tmp, emph)
		}
		{
			var tmp askew.BoundProperty
			tmp.Init(askew.WalkPath(block, 3, 1, 7), "textContent")
			askew.Assign(&tmp, itemName)
		}
		if indicator == InvisibilityIndicator {

		} else {
			_item := askew.WalkPath(block, 3, 1, 5)
			_parent := _item.Get("parentNode")
			_parent.Call("replaceChild", js.Global().Get("document").Call("createComment", "removed"), _item)
		}
		if indicator == VisibilityIndicator {

		} else {
			_item := askew.WalkPath(block, 3, 1, 3)
			_parent := _item.Get("parentNode")
			_parent.Call("replaceChild", js.Global().Get("document").Call("createComment", "removed"), _item)
		}
		if indicator == SelectionIndicator {

		} else {
			_item := askew.WalkPath(block, 3, 1, 1)
			_parent := _item.Get("parentNode")
			_parent.Call("replaceChild", js.Global().Get("document").Call("createComment", "removed"), _item)
		}
	}
	{
		src := o.αcd.Walk(3, 1)
		{
			wrapper := js.FuncOf(func(this js.Value, arguments []js.Value) interface{} {
				self := arguments[0].Get("currentTarget")
				var pindex askew.BoundDataset
				pindex.Init(self, "index")
				o.αcallclickItem(&pindex)
				arguments[0].Call("preventDefault")
				return nil
			})
			src.Call("addEventListener", "click", wrapper)
		}
	}
}

// InsertInto inserts this component into the given object.
// The component will be in inserted state afterwards.
//
// The component will be inserted in front of 'before', or at the end if 'before' is 'js.Undefined()'.
func (o *dropdownItem) InsertInto(parent js.Value, before js.Value) {
	o.αcd.DoInsert(parent, before)
}

// Extract removes this component from its current parent.
// The component will be in initial state afterwards.
func (o *dropdownItem) Extract() {
	o.αcd.DoExtract()
}

// Destroy destroys this element (and all contained components). If it is
// currently inserted anywhere, it gets removed before.
func (o *dropdownItem) Destroy() {
	o.αcd.DoDestroy()
}

func (o *dropdownItem) αcallclickItem(index askew.BoundValue) {
	if o.Controller == nil {
		return
	}
	_index := askew.IntValue{BoundValue: index}
	o.Controller.clickItem(_index.Get())
}

var αpopupInputTemplate = js.Global().Get("document").Call("createElement", "template")

func init() {
	αpopupInputTemplate.Set("innerHTML", `
	<!--data-->
  <label></label>
  <input type="text" required=""/>
`)
}

// popupInput is a DOM component autogenerated by Askew
type popupInput struct {
	αcd   askew.ComponentData
	Value askew.StringValue
	val   chan *string
}

// newPopupInput creates a new component and initializes it with the given parameters.
func newPopupInput(label string) *popupInput {
	ret := new(popupInput)
	ret.askewInit(label)
	return ret
}

// Init initializes the component with the given arguments.
func (o *popupInput) Init(label string) {
	o.askewInit(label)
}

// FirstNode returns the first DOM node of this component.
// It implements the askew.Component interface.
func (o *popupInput) FirstNode() js.Value {
	return o.αcd.First()
}

// askewInit initializes the component, discarding all previous information.
// The component is initially a DocumentFragment until it gets inserted into
// the main document. It can be manipulated both before and after insertion.
func (o *popupInput) askewInit(label string) {
	o.αcd.Init(αpopupInputTemplate.Get("content").Call("cloneNode", true))

	o.Value.BoundValue = askew.NewBoundProperty(&o.αcd, "value", 5)
	{
		block := o.αcd.Walk()
		{
			var tmp askew.BoundProperty
			tmp.Init(askew.WalkPath(block, 3), "textContent")
			askew.Assign(&tmp, label)
		}
	}
}

// InsertInto inserts this component into the given object.
// The component will be in inserted state afterwards.
//
// The component will be inserted in front of 'before', or at the end if 'before' is 'js.Undefined()'.
func (o *popupInput) InsertInto(parent js.Value, before js.Value) {
	o.αcd.DoInsert(parent, before)
}

// Extract removes this component from its current parent.
// The component will be in initial state afterwards.
func (o *popupInput) Extract() {
	o.αcd.DoExtract()
}

// Destroy destroys this element (and all contained components). If it is
// currently inserted anywhere, it gets removed before.
func (o *popupInput) Destroy() {
	o.αcd.DoDestroy()
}

var αpopupTemplateItemTemplate = js.Global().Get("document").Call("createElement", "template")

func init() {
	αpopupTemplateItemTemplate.Set("innerHTML", `
	<li class="pure-menu-item template-item">
		<a class="pure-menu-link" href="#">
			<div class="template-container">
				<p class="template-identifier">
					<span></span>
					<i class="fas fa-angle-right"></i>
					<span></span>
				</p>
				<p class="template-descr"></p>
			</div>
			<i class="fas fa-sort"></i>
		</a>
	</li>
`)
}

// popupTemplateItem is a DOM component autogenerated by Askew
type popupTemplateItem struct {
	αcd         askew.ComponentData
	PluginName  askew.StringValue
	Name        askew.StringValue
	Description askew.StringValue
}

// newPopupTemplateItem creates a new component and initializes it with the given parameters.
func newPopupTemplateItem() *popupTemplateItem {
	ret := new(popupTemplateItem)
	ret.askewInit()
	return ret
}

// Init initializes the component with the given arguments.
func (o *popupTemplateItem) Init() {
	o.askewInit()
}

// FirstNode returns the first DOM node of this component.
// It implements the askew.Component interface.
func (o *popupTemplateItem) FirstNode() js.Value {
	return o.αcd.First()
}

// askewInit initializes the component, discarding all previous information.
// The component is initially a DocumentFragment until it gets inserted into
// the main document. It can be manipulated both before and after insertion.
func (o *popupTemplateItem) askewInit() {
	o.αcd.Init(αpopupTemplateItemTemplate.Get("content").Call("cloneNode", true))

	o.PluginName.BoundValue = askew.NewBoundProperty(&o.αcd, "textContent", 1, 1, 1, 1, 1)
	o.Name.BoundValue = askew.NewBoundProperty(&o.αcd, "textContent", 1, 1, 1, 1, 5)
	o.Description.BoundValue = askew.NewBoundProperty(&o.αcd, "textContent", 1, 1, 1, 3)
}

// InsertInto inserts this component into the given object.
// The component will be in inserted state afterwards.
//
// The component will be inserted in front of 'before', or at the end if 'before' is 'js.Undefined()'.
func (o *popupTemplateItem) InsertInto(parent js.Value, before js.Value) {
	o.αcd.DoInsert(parent, before)
}

// Extract removes this component from its current parent.
// The component will be in initial state afterwards.
func (o *popupTemplateItem) Extract() {
	o.αcd.DoExtract()
}

// Destroy destroys this element (and all contained components). If it is
// currently inserted anywhere, it gets removed before.
func (o *popupTemplateItem) Destroy() {
	o.αcd.DoDestroy()
}

var αpopupTemplateListTemplate = js.Global().Get("document").Call("createElement", "template")

func init() {
	αpopupTemplateListTemplate.Set("innerHTML", `
	<div class="pure-menu template-list">
		<ul class="pure-menu-list"><!--embed(popupTemplateItem)--></ul>
	</div>
`)
}

// popupTemplateList is a DOM component autogenerated by Askew
type popupTemplateList struct {
	αcd               askew.ComponentData
	popupTemplateItem askew.GenericList
}

// newPopupTemplateList creates a new component and initializes it with the given parameters.
func newPopupTemplateList() *popupTemplateList {
	ret := new(popupTemplateList)
	ret.askewInit()
	return ret
}

// Init initializes the component with the given arguments.
func (o *popupTemplateList) Init() {
	o.askewInit()
}

// FirstNode returns the first DOM node of this component.
// It implements the askew.Component interface.
func (o *popupTemplateList) FirstNode() js.Value {
	return o.αcd.First()
}

// askewInit initializes the component, discarding all previous information.
// The component is initially a DocumentFragment until it gets inserted into
// the main document. It can be manipulated both before and after insertion.
func (o *popupTemplateList) askewInit() {
	o.αcd.Init(αpopupTemplateListTemplate.Get("content").Call("cloneNode", true))

	{
		container := o.αcd.Walk(1, 1)
		o.popupTemplateItem.Init(container, 0)

	}
}

// InsertInto inserts this component into the given object.
// The component will be in inserted state afterwards.
//
// The component will be inserted in front of 'before', or at the end if 'before' is 'js.Undefined()'.
func (o *popupTemplateList) InsertInto(parent js.Value, before js.Value) {
	o.αcd.DoInsert(parent, before)
	o.popupTemplateItem.DoUpdateParent(o.αcd.DocumentFragment(), parent, before)
}

// Extract removes this component from its current parent.
// The component will be in initial state afterwards.
func (o *popupTemplateList) Extract() {
	o.αcd.DoExtract()
	o.popupTemplateItem.DoUpdateParent(o.αcd.First().Get("parentNode"), o.αcd.DocumentFragment(), js.Undefined())
}

// Destroy destroys this element (and all contained components). If it is
// currently inserted anywhere, it gets removed before.
func (o *popupTemplateList) Destroy() {
	o.popupTemplateItem.DestroyAll()
	o.αcd.DoDestroy()
}

var αpopupTextTemplate = js.Global().Get("document").Call("createElement", "template")

func init() {
	αpopupTextTemplate.Set("innerHTML", `
	<!--data-->
  <!--a:text-->
`)
}

// popupText is a DOM component autogenerated by Askew
type popupText struct {
	αcd askew.ComponentData
	val chan bool
}

// newPopupText creates a new component and initializes it with the given parameters.
func newPopupText(caption string) *popupText {
	ret := new(popupText)
	ret.askewInit(caption)
	return ret
}

// Init initializes the component with the given arguments.
func (o *popupText) Init(caption string) {
	o.askewInit(caption)
}

// FirstNode returns the first DOM node of this component.
// It implements the askew.Component interface.
func (o *popupText) FirstNode() js.Value {
	return o.αcd.First()
}

// askewInit initializes the component, discarding all previous information.
// The component is initially a DocumentFragment until it gets inserted into
// the main document. It can be manipulated both before and after insertion.
func (o *popupText) askewInit(caption string) {
	o.αcd.Init(αpopupTextTemplate.Get("content").Call("cloneNode", true))
	o.val = make(chan bool, 1)

	{
		block := o.αcd.Walk()
		{
			var tmp askew.BoundSelf
			tmp.Init(askew.WalkPath(block, 3))
			askew.Assign(&tmp, caption)
		}
	}
}

// InsertInto inserts this component into the given object.
// The component will be in inserted state afterwards.
//
// The component will be inserted in front of 'before', or at the end if 'before' is 'js.Undefined()'.
func (o *popupText) InsertInto(parent js.Value, before js.Value) {
	o.αcd.DoInsert(parent, before)
}

// Extract removes this component from its current parent.
// The component will be in initial state afterwards.
func (o *popupText) Extract() {
	o.αcd.DoExtract()
}

// Destroy destroys this element (and all contained components). If it is
// currently inserted anywhere, it gets removed before.
func (o *popupText) Destroy() {
	o.αcd.DoDestroy()
}

// DropdownList is a list of Dropdown whose manipulation methods auto-update
// the corresponding nodes in the document.
type DropdownList struct {
	αmgr              askew.ListManager
	αitems            []*Dropdown
	DefaultController DropdownController
}

// Init initializes the list, discarding previous data.
// The list's items will be placed in the given container, starting at the
// given index.
func (l *DropdownList) Init(container js.Value, index int) {
	l.αmgr = askew.CreateListManager(container, index)
	l.αitems = nil
}

// Len returns the number of items in the list.
func (l *DropdownList) Len() int {
	return len(l.αitems)
}

// Item returns the item at the current index.
func (l *DropdownList) Item(index int) *Dropdown {
	return l.αitems[index]
}

// Append appends the given item to the list.
func (l *DropdownList) Append(item *Dropdown) {
	if item == nil {
		panic("cannot append nil to list")
	}
	l.αmgr.Append(item)
	l.αitems = append(l.αitems, item)
	item.Controller = l.DefaultController
	return
}

// Insert inserts the given item at the given index into the list.
func (l *DropdownList) Insert(index int, item *Dropdown) {
	var prev js.Value
	if index < len(l.αitems) {
		prev = l.αitems[index].αcd.First()
	}
	if item == nil {
		panic("cannot insert nil into list")
	}
	l.αmgr.Insert(item, prev)
	l.αitems = append(l.αitems, nil)
	copy(l.αitems[index+1:], l.αitems[index:])
	l.αitems[index] = item
	item.Controller = l.DefaultController
	return
}

// Remove removes the item at the given index from the list and returns it.
func (l *DropdownList) Remove(index int) *Dropdown {
	item := l.αitems[index]
	item.Extract()
	copy(l.αitems[index:], l.αitems[index+1:])
	l.αitems = l.αitems[:len(l.αitems)-1]
	return item
}

// Destroy destroys the item at the given index and removes it from the list.
func (l *DropdownList) Destroy(index int) {
	item := l.αitems[index]
	item.Destroy()
	copy(l.αitems[index:], l.αitems[index+1:])
	l.αitems = l.αitems[:len(l.αitems)-1]
}

// DestroyAll destroys all items in the list and empties it.
func (l *DropdownList) DestroyAll() {
	for _, item := range l.αitems {
		item.Destroy()
	}
	l.αitems = l.αitems[:0]
}

// PopupBaseList is a list of PopupBase whose manipulation methods auto-update
// the corresponding nodes in the document.
type PopupBaseList struct {
	αmgr              askew.ListManager
	αitems            []*PopupBase
	DefaultController PopupBaseController
}

// Init initializes the list, discarding previous data.
// The list's items will be placed in the given container, starting at the
// given index.
func (l *PopupBaseList) Init(container js.Value, index int) {
	l.αmgr = askew.CreateListManager(container, index)
	l.αitems = nil
}

// Len returns the number of items in the list.
func (l *PopupBaseList) Len() int {
	return len(l.αitems)
}

// Item returns the item at the current index.
func (l *PopupBaseList) Item(index int) *PopupBase {
	return l.αitems[index]
}

// Append appends the given item to the list.
func (l *PopupBaseList) Append(item *PopupBase) {
	if item == nil {
		panic("cannot append nil to list")
	}
	l.αmgr.Append(item)
	l.αitems = append(l.αitems, item)
	item.Controller = l.DefaultController
	return
}

// Insert inserts the given item at the given index into the list.
func (l *PopupBaseList) Insert(index int, item *PopupBase) {
	var prev js.Value
	if index < len(l.αitems) {
		prev = l.αitems[index].αcd.First()
	}
	if item == nil {
		panic("cannot insert nil into list")
	}
	l.αmgr.Insert(item, prev)
	l.αitems = append(l.αitems, nil)
	copy(l.αitems[index+1:], l.αitems[index:])
	l.αitems[index] = item
	item.Controller = l.DefaultController
	return
}

// Remove removes the item at the given index from the list and returns it.
func (l *PopupBaseList) Remove(index int) *PopupBase {
	item := l.αitems[index]
	item.Extract()
	copy(l.αitems[index:], l.αitems[index+1:])
	l.αitems = l.αitems[:len(l.αitems)-1]
	return item
}

// Destroy destroys the item at the given index and removes it from the list.
func (l *PopupBaseList) Destroy(index int) {
	item := l.αitems[index]
	item.Destroy()
	copy(l.αitems[index:], l.αitems[index+1:])
	l.αitems = l.αitems[:len(l.αitems)-1]
}

// DestroyAll destroys all items in the list and empties it.
func (l *PopupBaseList) DestroyAll() {
	for _, item := range l.αitems {
		item.Destroy()
	}
	l.αitems = l.αitems[:0]
}

// SwitchList is a list of Switch whose manipulation methods auto-update
// the corresponding nodes in the document.
type SwitchList struct {
	αmgr              askew.ListManager
	αitems            []*Switch
	DefaultController SwitchController
}

// Init initializes the list, discarding previous data.
// The list's items will be placed in the given container, starting at the
// given index.
func (l *SwitchList) Init(container js.Value, index int) {
	l.αmgr = askew.CreateListManager(container, index)
	l.αitems = nil
}

// Len returns the number of items in the list.
func (l *SwitchList) Len() int {
	return len(l.αitems)
}

// Item returns the item at the current index.
func (l *SwitchList) Item(index int) *Switch {
	return l.αitems[index]
}

// Append appends the given item to the list.
func (l *SwitchList) Append(item *Switch) {
	if item == nil {
		panic("cannot append nil to list")
	}
	l.αmgr.Append(item)
	l.αitems = append(l.αitems, item)
	item.Controller = l.DefaultController
	return
}

// Insert inserts the given item at the given index into the list.
func (l *SwitchList) Insert(index int, item *Switch) {
	var prev js.Value
	if index < len(l.αitems) {
		prev = l.αitems[index].αcd.First()
	}
	if item == nil {
		panic("cannot insert nil into list")
	}
	l.αmgr.Insert(item, prev)
	l.αitems = append(l.αitems, nil)
	copy(l.αitems[index+1:], l.αitems[index:])
	l.αitems[index] = item
	item.Controller = l.DefaultController
	return
}

// Remove removes the item at the given index from the list and returns it.
func (l *SwitchList) Remove(index int) *Switch {
	item := l.αitems[index]
	item.Extract()
	copy(l.αitems[index:], l.αitems[index+1:])
	l.αitems = l.αitems[:len(l.αitems)-1]
	return item
}

// Destroy destroys the item at the given index and removes it from the list.
func (l *SwitchList) Destroy(index int) {
	item := l.αitems[index]
	item.Destroy()
	copy(l.αitems[index:], l.αitems[index+1:])
	l.αitems = l.αitems[:len(l.αitems)-1]
}

// DestroyAll destroys all items in the list and empties it.
func (l *SwitchList) DestroyAll() {
	for _, item := range l.αitems {
		item.Destroy()
	}
	l.αitems = l.αitems[:0]
}

// dropdownItemList is a list of dropdownItem whose manipulation methods auto-update
// the corresponding nodes in the document.
type dropdownItemList struct {
	αmgr              askew.ListManager
	αitems            []*dropdownItem
	DefaultController dropdownItemController
}

// Init initializes the list, discarding previous data.
// The list's items will be placed in the given container, starting at the
// given index.
func (l *dropdownItemList) Init(container js.Value, index int) {
	l.αmgr = askew.CreateListManager(container, index)
	l.αitems = nil
}

// Len returns the number of items in the list.
func (l *dropdownItemList) Len() int {
	return len(l.αitems)
}

// Item returns the item at the current index.
func (l *dropdownItemList) Item(index int) *dropdownItem {
	return l.αitems[index]
}

// Append appends the given item to the list.
func (l *dropdownItemList) Append(item *dropdownItem) {
	if item == nil {
		panic("cannot append nil to list")
	}
	l.αmgr.Append(item)
	l.αitems = append(l.αitems, item)
	item.Controller = l.DefaultController
	return
}

// Insert inserts the given item at the given index into the list.
func (l *dropdownItemList) Insert(index int, item *dropdownItem) {
	var prev js.Value
	if index < len(l.αitems) {
		prev = l.αitems[index].αcd.First()
	}
	if item == nil {
		panic("cannot insert nil into list")
	}
	l.αmgr.Insert(item, prev)
	l.αitems = append(l.αitems, nil)
	copy(l.αitems[index+1:], l.αitems[index:])
	l.αitems[index] = item
	item.Controller = l.DefaultController
	return
}

// Remove removes the item at the given index from the list and returns it.
func (l *dropdownItemList) Remove(index int) *dropdownItem {
	item := l.αitems[index]
	item.Extract()
	copy(l.αitems[index:], l.αitems[index+1:])
	l.αitems = l.αitems[:len(l.αitems)-1]
	return item
}

// Destroy destroys the item at the given index and removes it from the list.
func (l *dropdownItemList) Destroy(index int) {
	item := l.αitems[index]
	item.Destroy()
	copy(l.αitems[index:], l.αitems[index+1:])
	l.αitems = l.αitems[:len(l.αitems)-1]
}

// DestroyAll destroys all items in the list and empties it.
func (l *dropdownItemList) DestroyAll() {
	for _, item := range l.αitems {
		item.Destroy()
	}
	l.αitems = l.αitems[:0]
}

// popupInputList is a list of popupInput whose manipulation methods auto-update
// the corresponding nodes in the document.
type popupInputList struct {
	αmgr   askew.ListManager
	αitems []*popupInput
}

// Init initializes the list, discarding previous data.
// The list's items will be placed in the given container, starting at the
// given index.
func (l *popupInputList) Init(container js.Value, index int) {
	l.αmgr = askew.CreateListManager(container, index)
	l.αitems = nil
}

// Len returns the number of items in the list.
func (l *popupInputList) Len() int {
	return len(l.αitems)
}

// Item returns the item at the current index.
func (l *popupInputList) Item(index int) *popupInput {
	return l.αitems[index]
}

// Append appends the given item to the list.
func (l *popupInputList) Append(item *popupInput) {
	if item == nil {
		panic("cannot append nil to list")
	}
	l.αmgr.Append(item)
	l.αitems = append(l.αitems, item)
	return
}

// Insert inserts the given item at the given index into the list.
func (l *popupInputList) Insert(index int, item *popupInput) {
	var prev js.Value
	if index < len(l.αitems) {
		prev = l.αitems[index].αcd.First()
	}
	if item == nil {
		panic("cannot insert nil into list")
	}
	l.αmgr.Insert(item, prev)
	l.αitems = append(l.αitems, nil)
	copy(l.αitems[index+1:], l.αitems[index:])
	l.αitems[index] = item
	return
}

// Remove removes the item at the given index from the list and returns it.
func (l *popupInputList) Remove(index int) *popupInput {
	item := l.αitems[index]
	item.Extract()
	copy(l.αitems[index:], l.αitems[index+1:])
	l.αitems = l.αitems[:len(l.αitems)-1]
	return item
}

// Destroy destroys the item at the given index and removes it from the list.
func (l *popupInputList) Destroy(index int) {
	item := l.αitems[index]
	item.Destroy()
	copy(l.αitems[index:], l.αitems[index+1:])
	l.αitems = l.αitems[:len(l.αitems)-1]
}

// DestroyAll destroys all items in the list and empties it.
func (l *popupInputList) DestroyAll() {
	for _, item := range l.αitems {
		item.Destroy()
	}
	l.αitems = l.αitems[:0]
}

// popupTemplateItemList is a list of popupTemplateItem whose manipulation methods auto-update
// the corresponding nodes in the document.
type popupTemplateItemList struct {
	αmgr   askew.ListManager
	αitems []*popupTemplateItem
}

// Init initializes the list, discarding previous data.
// The list's items will be placed in the given container, starting at the
// given index.
func (l *popupTemplateItemList) Init(container js.Value, index int) {
	l.αmgr = askew.CreateListManager(container, index)
	l.αitems = nil
}

// Len returns the number of items in the list.
func (l *popupTemplateItemList) Len() int {
	return len(l.αitems)
}

// Item returns the item at the current index.
func (l *popupTemplateItemList) Item(index int) *popupTemplateItem {
	return l.αitems[index]
}

// Append appends the given item to the list.
func (l *popupTemplateItemList) Append(item *popupTemplateItem) {
	if item == nil {
		panic("cannot append nil to list")
	}
	l.αmgr.Append(item)
	l.αitems = append(l.αitems, item)
	return
}

// Insert inserts the given item at the given index into the list.
func (l *popupTemplateItemList) Insert(index int, item *popupTemplateItem) {
	var prev js.Value
	if index < len(l.αitems) {
		prev = l.αitems[index].αcd.First()
	}
	if item == nil {
		panic("cannot insert nil into list")
	}
	l.αmgr.Insert(item, prev)
	l.αitems = append(l.αitems, nil)
	copy(l.αitems[index+1:], l.αitems[index:])
	l.αitems[index] = item
	return
}

// Remove removes the item at the given index from the list and returns it.
func (l *popupTemplateItemList) Remove(index int) *popupTemplateItem {
	item := l.αitems[index]
	item.Extract()
	copy(l.αitems[index:], l.αitems[index+1:])
	l.αitems = l.αitems[:len(l.αitems)-1]
	return item
}

// Destroy destroys the item at the given index and removes it from the list.
func (l *popupTemplateItemList) Destroy(index int) {
	item := l.αitems[index]
	item.Destroy()
	copy(l.αitems[index:], l.αitems[index+1:])
	l.αitems = l.αitems[:len(l.αitems)-1]
}

// DestroyAll destroys all items in the list and empties it.
func (l *popupTemplateItemList) DestroyAll() {
	for _, item := range l.αitems {
		item.Destroy()
	}
	l.αitems = l.αitems[:0]
}

// popupTemplateListList is a list of popupTemplateList whose manipulation methods auto-update
// the corresponding nodes in the document.
type popupTemplateListList struct {
	αmgr   askew.ListManager
	αitems []*popupTemplateList
}

// Init initializes the list, discarding previous data.
// The list's items will be placed in the given container, starting at the
// given index.
func (l *popupTemplateListList) Init(container js.Value, index int) {
	l.αmgr = askew.CreateListManager(container, index)
	l.αitems = nil
}

// Len returns the number of items in the list.
func (l *popupTemplateListList) Len() int {
	return len(l.αitems)
}

// Item returns the item at the current index.
func (l *popupTemplateListList) Item(index int) *popupTemplateList {
	return l.αitems[index]
}

// Append appends the given item to the list.
func (l *popupTemplateListList) Append(item *popupTemplateList) {
	if item == nil {
		panic("cannot append nil to list")
	}
	l.αmgr.Append(item)
	l.αitems = append(l.αitems, item)
	return
}

// Insert inserts the given item at the given index into the list.
func (l *popupTemplateListList) Insert(index int, item *popupTemplateList) {
	var prev js.Value
	if index < len(l.αitems) {
		prev = l.αitems[index].αcd.First()
	}
	if item == nil {
		panic("cannot insert nil into list")
	}
	l.αmgr.Insert(item, prev)
	l.αitems = append(l.αitems, nil)
	copy(l.αitems[index+1:], l.αitems[index:])
	l.αitems[index] = item
	return
}

// Remove removes the item at the given index from the list and returns it.
func (l *popupTemplateListList) Remove(index int) *popupTemplateList {
	item := l.αitems[index]
	item.Extract()
	copy(l.αitems[index:], l.αitems[index+1:])
	l.αitems = l.αitems[:len(l.αitems)-1]
	return item
}

// Destroy destroys the item at the given index and removes it from the list.
func (l *popupTemplateListList) Destroy(index int) {
	item := l.αitems[index]
	item.Destroy()
	copy(l.αitems[index:], l.αitems[index+1:])
	l.αitems = l.αitems[:len(l.αitems)-1]
}

// DestroyAll destroys all items in the list and empties it.
func (l *popupTemplateListList) DestroyAll() {
	for _, item := range l.αitems {
		item.Destroy()
	}
	l.αitems = l.αitems[:0]
}

// popupTextList is a list of popupText whose manipulation methods auto-update
// the corresponding nodes in the document.
type popupTextList struct {
	αmgr   askew.ListManager
	αitems []*popupText
}

// Init initializes the list, discarding previous data.
// The list's items will be placed in the given container, starting at the
// given index.
func (l *popupTextList) Init(container js.Value, index int) {
	l.αmgr = askew.CreateListManager(container, index)
	l.αitems = nil
}

// Len returns the number of items in the list.
func (l *popupTextList) Len() int {
	return len(l.αitems)
}

// Item returns the item at the current index.
func (l *popupTextList) Item(index int) *popupText {
	return l.αitems[index]
}

// Append appends the given item to the list.
func (l *popupTextList) Append(item *popupText) {
	if item == nil {
		panic("cannot append nil to list")
	}
	l.αmgr.Append(item)
	l.αitems = append(l.αitems, item)
	return
}

// Insert inserts the given item at the given index into the list.
func (l *popupTextList) Insert(index int, item *popupText) {
	var prev js.Value
	if index < len(l.αitems) {
		prev = l.αitems[index].αcd.First()
	}
	if item == nil {
		panic("cannot insert nil into list")
	}
	l.αmgr.Insert(item, prev)
	l.αitems = append(l.αitems, nil)
	copy(l.αitems[index+1:], l.αitems[index:])
	l.αitems[index] = item
	return
}

// Remove removes the item at the given index from the list and returns it.
func (l *popupTextList) Remove(index int) *popupText {
	item := l.αitems[index]
	item.Extract()
	copy(l.αitems[index:], l.αitems[index+1:])
	l.αitems = l.αitems[:len(l.αitems)-1]
	return item
}

// Destroy destroys the item at the given index and removes it from the list.
func (l *popupTextList) Destroy(index int) {
	item := l.αitems[index]
	item.Destroy()
	copy(l.αitems[index:], l.αitems[index+1:])
	l.αitems = l.αitems[:len(l.αitems)-1]
}

// DestroyAll destroys all items in the list and empties it.
func (l *popupTextList) DestroyAll() {
	for _, item := range l.αitems {
		item.Destroy()
	}
	l.αitems = l.αitems[:0]
}

// OptionalDropdown is a nillable embeddable container for Dropdown.
type OptionalDropdown struct {
	αcur              *Dropdown
	αmgr              askew.ListManager
	DefaultController DropdownController
}

// Init initializes the container to be empty.
// The contained item, if any, will be placed in the given container at the
// given index.
func (o *OptionalDropdown) Init(container js.Value, index int) {
	o.αmgr = askew.CreateListManager(container, index)
	o.αcur = nil
}

// Item returns the current item, or nil if no item is assigned
func (o *OptionalDropdown) Item() *Dropdown {
	return o.αcur
}

// Set sets the contained item destroying the current one.
// Give nil as value to simply destroy the current item.
func (o *OptionalDropdown) Set(value *Dropdown) {
	if o.αcur != nil {
		o.αcur.Destroy()
	}
	o.αcur = value
	if value != nil {
		o.αmgr.Append(value)
		value.Controller = o.DefaultController
	}
}

// Remove removes the current item and returns it.
// Returns nil if there is no current item.
func (o *OptionalDropdown) Remove() askew.Component {
	if o.αcur != nil {
		ret := o.αcur
		ret.Extract()
		o.αcur = nil
		return ret
	}
	return nil
}

// OptionalPopupBase is a nillable embeddable container for PopupBase.
type OptionalPopupBase struct {
	αcur              *PopupBase
	αmgr              askew.ListManager
	DefaultController PopupBaseController
}

// Init initializes the container to be empty.
// The contained item, if any, will be placed in the given container at the
// given index.
func (o *OptionalPopupBase) Init(container js.Value, index int) {
	o.αmgr = askew.CreateListManager(container, index)
	o.αcur = nil
}

// Item returns the current item, or nil if no item is assigned
func (o *OptionalPopupBase) Item() *PopupBase {
	return o.αcur
}

// Set sets the contained item destroying the current one.
// Give nil as value to simply destroy the current item.
func (o *OptionalPopupBase) Set(value *PopupBase) {
	if o.αcur != nil {
		o.αcur.Destroy()
	}
	o.αcur = value
	if value != nil {
		o.αmgr.Append(value)
		value.Controller = o.DefaultController
	}
}

// Remove removes the current item and returns it.
// Returns nil if there is no current item.
func (o *OptionalPopupBase) Remove() askew.Component {
	if o.αcur != nil {
		ret := o.αcur
		ret.Extract()
		o.αcur = nil
		return ret
	}
	return nil
}

// OptionalSwitch is a nillable embeddable container for Switch.
type OptionalSwitch struct {
	αcur              *Switch
	αmgr              askew.ListManager
	DefaultController SwitchController
}

// Init initializes the container to be empty.
// The contained item, if any, will be placed in the given container at the
// given index.
func (o *OptionalSwitch) Init(container js.Value, index int) {
	o.αmgr = askew.CreateListManager(container, index)
	o.αcur = nil
}

// Item returns the current item, or nil if no item is assigned
func (o *OptionalSwitch) Item() *Switch {
	return o.αcur
}

// Set sets the contained item destroying the current one.
// Give nil as value to simply destroy the current item.
func (o *OptionalSwitch) Set(value *Switch) {
	if o.αcur != nil {
		o.αcur.Destroy()
	}
	o.αcur = value
	if value != nil {
		o.αmgr.Append(value)
		value.Controller = o.DefaultController
	}
}

// Remove removes the current item and returns it.
// Returns nil if there is no current item.
func (o *OptionalSwitch) Remove() askew.Component {
	if o.αcur != nil {
		ret := o.αcur
		ret.Extract()
		o.αcur = nil
		return ret
	}
	return nil
}

// OptionaldropdownItem is a nillable embeddable container for dropdownItem.
type OptionaldropdownItem struct {
	αcur              *dropdownItem
	αmgr              askew.ListManager
	DefaultController dropdownItemController
}

// Init initializes the container to be empty.
// The contained item, if any, will be placed in the given container at the
// given index.
func (o *OptionaldropdownItem) Init(container js.Value, index int) {
	o.αmgr = askew.CreateListManager(container, index)
	o.αcur = nil
}

// Item returns the current item, or nil if no item is assigned
func (o *OptionaldropdownItem) Item() *dropdownItem {
	return o.αcur
}

// Set sets the contained item destroying the current one.
// Give nil as value to simply destroy the current item.
func (o *OptionaldropdownItem) Set(value *dropdownItem) {
	if o.αcur != nil {
		o.αcur.Destroy()
	}
	o.αcur = value
	if value != nil {
		o.αmgr.Append(value)
		value.Controller = o.DefaultController
	}
}

// Remove removes the current item and returns it.
// Returns nil if there is no current item.
func (o *OptionaldropdownItem) Remove() askew.Component {
	if o.αcur != nil {
		ret := o.αcur
		ret.Extract()
		o.αcur = nil
		return ret
	}
	return nil
}

// OptionalpopupInput is a nillable embeddable container for popupInput.
type OptionalpopupInput struct {
	αcur *popupInput
	αmgr askew.ListManager
}

// Init initializes the container to be empty.
// The contained item, if any, will be placed in the given container at the
// given index.
func (o *OptionalpopupInput) Init(container js.Value, index int) {
	o.αmgr = askew.CreateListManager(container, index)
	o.αcur = nil
}

// Item returns the current item, or nil if no item is assigned
func (o *OptionalpopupInput) Item() *popupInput {
	return o.αcur
}

// Set sets the contained item destroying the current one.
// Give nil as value to simply destroy the current item.
func (o *OptionalpopupInput) Set(value *popupInput) {
	if o.αcur != nil {
		o.αcur.Destroy()
	}
	o.αcur = value
	if value != nil {
		o.αmgr.Append(value)
	}
}

// Remove removes the current item and returns it.
// Returns nil if there is no current item.
func (o *OptionalpopupInput) Remove() askew.Component {
	if o.αcur != nil {
		ret := o.αcur
		ret.Extract()
		o.αcur = nil
		return ret
	}
	return nil
}

// OptionalpopupTemplateItem is a nillable embeddable container for popupTemplateItem.
type OptionalpopupTemplateItem struct {
	αcur *popupTemplateItem
	αmgr askew.ListManager
}

// Init initializes the container to be empty.
// The contained item, if any, will be placed in the given container at the
// given index.
func (o *OptionalpopupTemplateItem) Init(container js.Value, index int) {
	o.αmgr = askew.CreateListManager(container, index)
	o.αcur = nil
}

// Item returns the current item, or nil if no item is assigned
func (o *OptionalpopupTemplateItem) Item() *popupTemplateItem {
	return o.αcur
}

// Set sets the contained item destroying the current one.
// Give nil as value to simply destroy the current item.
func (o *OptionalpopupTemplateItem) Set(value *popupTemplateItem) {
	if o.αcur != nil {
		o.αcur.Destroy()
	}
	o.αcur = value
	if value != nil {
		o.αmgr.Append(value)
	}
}

// Remove removes the current item and returns it.
// Returns nil if there is no current item.
func (o *OptionalpopupTemplateItem) Remove() askew.Component {
	if o.αcur != nil {
		ret := o.αcur
		ret.Extract()
		o.αcur = nil
		return ret
	}
	return nil
}

// OptionalpopupTemplateList is a nillable embeddable container for popupTemplateList.
type OptionalpopupTemplateList struct {
	αcur *popupTemplateList
	αmgr askew.ListManager
}

// Init initializes the container to be empty.
// The contained item, if any, will be placed in the given container at the
// given index.
func (o *OptionalpopupTemplateList) Init(container js.Value, index int) {
	o.αmgr = askew.CreateListManager(container, index)
	o.αcur = nil
}

// Item returns the current item, or nil if no item is assigned
func (o *OptionalpopupTemplateList) Item() *popupTemplateList {
	return o.αcur
}

// Set sets the contained item destroying the current one.
// Give nil as value to simply destroy the current item.
func (o *OptionalpopupTemplateList) Set(value *popupTemplateList) {
	if o.αcur != nil {
		o.αcur.Destroy()
	}
	o.αcur = value
	if value != nil {
		o.αmgr.Append(value)
	}
}

// Remove removes the current item and returns it.
// Returns nil if there is no current item.
func (o *OptionalpopupTemplateList) Remove() askew.Component {
	if o.αcur != nil {
		ret := o.αcur
		ret.Extract()
		o.αcur = nil
		return ret
	}
	return nil
}

// OptionalpopupText is a nillable embeddable container for popupText.
type OptionalpopupText struct {
	αcur *popupText
	αmgr askew.ListManager
}

// Init initializes the container to be empty.
// The contained item, if any, will be placed in the given container at the
// given index.
func (o *OptionalpopupText) Init(container js.Value, index int) {
	o.αmgr = askew.CreateListManager(container, index)
	o.αcur = nil
}

// Item returns the current item, or nil if no item is assigned
func (o *OptionalpopupText) Item() *popupText {
	return o.αcur
}

// Set sets the contained item destroying the current one.
// Give nil as value to simply destroy the current item.
func (o *OptionalpopupText) Set(value *popupText) {
	if o.αcur != nil {
		o.αcur.Destroy()
	}
	o.αcur = value
	if value != nil {
		o.αmgr.Append(value)
	}
}

// Remove removes the current item and returns it.
// Returns nil if there is no current item.
func (o *OptionalpopupText) Remove() askew.Component {
	if o.αcur != nil {
		ret := o.αcur
		ret.Extract()
		o.αcur = nil
		return ret
	}
	return nil
}
